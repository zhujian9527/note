选择排序:每次过一遍数组 找到最大值 放到i的位置 i++
冒泡排序：每次过一遍数组 交换相邻的两个数 一直到每一轮的最大值放到后面去
异或运算
题目：  
    1.一个数组中只有一个数出现次数为奇数次 其他全为偶数次   求这个奇数次的数  
        （从头到尾异或）
    2. 1的升级版 一个数组中有两个数出现次数为奇数次 其他全为偶数次   求这两个个奇数次的数  
         从头到尾异或得到eor1 =a^b 提取出eor1中最右侧的1得到 int temp 再过一遍数组 如果 数组中某个数&temp ==0，就让这个数和eor2异或
         过完数组 eor2就是a或者b其中的一个  eor2^eor1得到剩余的一个 
         技巧  提取出一个数中最右侧的1  a&(~a+1)  得到 二进制只有一个1的数

插入排序：前I个元素有序  第i+1个元素过一遍i个数组  i+1位置的元素比i大 就交换


复杂度 0()  一律按照最差情况估计
    比如插入排序按从大到小的顺序排序  如果数据本来就是从大到小有序  O(N)
    如果数据从小到大排序的 O(N^2)

二分查找
    leetcode 162 852 1095

递归算法的时间复杂度 
    T [n] = aT[n/b] + f (n)（直接记为T [n] = aT[n/b] + T (N^d)）
        其中 a >= 1 and b > 1 是常量，其表示的意义是n表示问题的规模，a表示递归的次数也就是生成的子问题数，b表示每次递归是原来的1/b之一个规模，f（n）表示分解和合并所要花费的时间之和。
        解法：
        ①当d<logb a时，时间复杂度为O(n^(logb a))
        ②当d=logb a时，时间复杂度为O((n^d)*logn)
        ③当d>logb a时，时间复杂度为O(n^d)


归并排序  时间复杂度 (nlogn) 空间(nlogn)  可优化空间复杂度为0(1)

小和问题  数组中  一个元素右边比他小的元素累加和 叫做这个元素的小和   对每一个元素求小和累加起来的结果 就是小和结果
    思路转变  相当于求一个数 右侧比他大的数之和   对每一个数这样求，结果累加
    可以在归并排序merge过程中去统计每一个数右侧有多少数比他大并求和

逆序对问题  
    一个数组中 左侧的数大于右侧的数，则这两个数构成逆序对  打印所有的逆序对
    求所有逆序对的和   leetcode     剑指offer51

给定一个值 使得数组中小于该值的数放左边 大于该值的数放右边
荷兰国旗问题  leetcode 75


快排 
    1.0  
    取数组最后一个元素做target  对前n-1个数 让小于等于的放左边 大于的放右边，然后交换最后一个值和大于区域的第一个元素
    然后根据target的坐标，左右两侧划分为两个区域 递归此过程  每次递归能保证有一个数被排好位置
    2.0版本
    也是取数组最后一个元素做target，利用荷兰国旗问题，将前n-1个数划分为小于 等于 大于 三个区域，然后交换最后一个元素
    和大于区域的第一个元素，然后划分小于区域和大于区域 递归下去 这样每次能排序好多个相同的数 效率高于1.0

    1.0和2.0 时间复杂度度都是0(N^2) 最差情况如 [1,2,3,4,5,6,7,8,9]  每次会让一侧区域为空

    3.0版本  随机选一个数组中的数当做target，target和数组最后一个元素交换  执行2.0版本  
        时间复杂度 0(n*logn)  空间复杂度0(logN)



堆
    一颗满二叉树  最大值或者最小值在顶点,对每颗子树也满足这个条件  
    二叉树用数组表示  i位置 左孩子是 2*i+1  右孩子是 2*i+2  父节点  (i-1)/2向下取整

    insert过程  新插入进来的节点和它的父节点比较 如大于父节点就交换 重复这个过程直到到达堆顶或者不大于父节点了
                heapSize --,将数组最后一个元素和根元素交换 ，选取根节点的两个孩子中最大的一个，如果这个最大值
    返回并移除最大值            大于根节点，就交换，然后比较交换过后的子节点和他的左右孩子 重复这个过程  

    堆插入 O(logN) 返回并移除最大值  0(logN)


堆排序 
    给定一个数组  一个一个往大根堆插入  构成大根堆之后  对这个数组 把数组头元素和headSize处的元素交换 
    这样每次最大值就到了数组的最后，然后heapSize -- 这个 堆就变小了一个从小到大的排序
    0(nlogn) O(1)

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元 素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的 排序算法针对这个数据进行排序
    解题思路 ： 选一个容量为k+1的小根堆  遍历数组 依次添加进入heap，满了只有就弹出最小值，从数组下标为0开始，依次填入数组  遍历到最后k个元素的时候，没有元素添加，直接弹出最小值写入数组


非比较的排序算法
    桶排序
        1. 计数排序   
            给定一个数组 先求出最大值和最小值 开辟一个max-min+1 大小的桶(或者数组、队列) 
            遍历数组 对于值为x的数组 放在索引值为x-min+1的位置上,
            遍历之后可得到从小到大每个元素出现的次数  遍历这个桶 依次输出
            /**
            优化 ： 如果出现多个相同的数 要确定哪个是哪个 做法就是 遍历这个桶 当前桶的值=前面所有桶的值之和+当前桶     (此时桶的值的含义是 当前数组中下标对应的元素x应该排在哪个位置上)
            然后从后往前遍历数组 数组值为x的元素在桶的x-min+1上,然后将这个元素输出，再讲桶对应的值-1
            **/
        2. 基数排序
            将数据按照个位、十位、百位、千位等分别放在0-9的桶中，然后遍历桶取出  （一个桶中的元素先进先出）
            按照每一位这样进桶出桶之后就会有序



 链表
    打印两个有序链表的公共部分
    单链表翻转
    双向链表翻转
    链表在a到b个元素上翻转
    链表是否回文          
    链表是否有环
    链表是否相交
    将单向链表按某值划分成左边小、中间相等、右边大的形式 
    rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节 点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。

树
    前序遍历 
    中序遍历
    后序遍历
    层次遍历
    四种遍历方式的非递归实现
    给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点
    后继节点：中序遍历中一个节点的后面节点
    二叉树的序列化和反序列化 就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树 如何判断一颗二叉树是不是另一棵二叉树的子树？
    如何判断一颗二叉树是否是搜索二叉树？ 如何判断一颗二叉树是完全二叉树？ 如何判断一颗二叉树是否是满二叉树？ 如何判断一颗二叉树是否是平衡二叉树？（二叉树题目套路）
图  
    宽度优先遍历
    广度优先遍历
    拓扑排序
    k算法 
    p算法
    d算法


前缀树

贪心

布隆过滤器  (给定样本量和失误率，可以计算出需要的内存大小 hash函数的个数  以及实际的失误率) 
一致性hash (虚拟节点抢占)

岛屿问题
    岛屿问题用并行算法
并查集
kmp
manacher算法（O（n）查找一个字符串的最长回文子串）

滑动窗口  （窗口内最大值或者最小值更新结构）
    一个窗口LR 可以选择L或者R往右移动，但L不能超过R 维护这个窗口的最大值
    流程  准备一个双端队列  目标:随时获取窗口内最大值 双端队列存放数组下标
        滑动过程中保证队列内元素有序  L为头部 R为尾部
        如果让R动  判断此时要进入的元素是否大于队列中头部元素
           如果元素小于队列头部元素 则元素从尾部进入队列  
           否则队列内的元素从尾部开始一条一条弹出，知道队列为空或者队列头部节点大于待进入的元素
            即窗口内从左到右依次减小，当进入一个元素时，从右往左依次弹出，一直到这个元素
            可以放进一个大于它的元素的后面
            3 2 4 6 3 7 5 3 5  R往右动  维持最大值在头部 就是L处
            [3]  [3,2]  [4](2,3依次弹出) [6] [6,3] [7][7 5 ][7,5,3] [7,5](3,5依次弹出 然后新的5进入  严格保证弹出元素小于当前进入元素)
            L往右动的时候 
                如果过期的元素是头部元素 就弹出
                如果过期元素不是头部元素 不用管
                L R 实际上是两个代表位置的遍历   双端队列里面是从大到小的元素

                6 4 2 5 3 
                如果R到达下标为2的位置  双端队列 [0,1,2] (头--- 尾) 放的下标
                此时 L=0， R=2 此时L右移 L=1 查看下标为0的元素是不是队列的头部元素
                  是的  所以6移除
                  L再右移 4移除  
                  此时R右移  到下标为4的位置  队列中[3,4]（也就是5,3）
                  此时L右移 发现下标为2的位置不是队列中的头部元素 什么都不做


单调栈（一个数组中每一个元素左边比他大且距离最近的元素和右边比他大且距离最近的元素）0(n)
 5 4 3 6 1 2 0 7
   流程： 如果求左右两边比当前元素大的  就准备一个单调栈(从栈底到栈顶从大到小)
   流程： 如果求左右两边比当前元素小的  就准备一个单调栈(从栈底到栈顶从小到大)
        依次遍历  下标放入栈底
        假设栈底~栈顶 从左到右 []
        [0,1,2] 此时来到6 发现不能放入栈顶 弹出栈顶
          弹出时弹出a2  此时 a2右边比他大的数就是6 右边比他大的数就是他在栈中的下一个元素 a1  记录(a1,a3)
          然后弹出a1  同理 记录  (a1,a3)
          然后弹出a0 (null,a3)
          然后a3压入栈底
       




树形DP


Morris遍历
    利用叶节点的空闲指针代替栈完成遍历
    遍历规则
    假设当前来到cur节点
    1. 如果cur没有左孩子 cur向右移动 cur =cur.right
    2. 如果cur有左孩子 找到左子树上最右的节点 mostRight
        2.1  如果mostRight的右指针指向空，让其指向cur
             然后cur向左移  cur =cur.left   重复这个过程
        2.2 如果mostRight的右指针指向cur，让其指向null
            然后cur向右移   cur =cur.right  重复这个过程
    3. cur为空时遍历停止
    有左树的节点能到两次，没有左树的节点只能到一次

    morris遍历改先序遍历
        如果一个节点只能到达一次 直接打印   能到达两次  第一次打印
    morris遍历改中序遍历
        如果节点只能到达一次  直接打印  能到达两次 第二次打印
    morris遍历改后序遍历
        对于第二次遍历的节点，逆序打印左树的右边界
        遍历完之后单独逆序打印整棵树的右边界
    
    判断一棵树是不是搜索二叉树
    如果中序遍历是升序就是搜索二叉树
    bitmap   40亿个数在整数范围上(大概是42亿)  在 1G范围内 判断哪个数没有出现过
    42亿/8差不多 512M 大小  生成一个bit类型的数组  512M  每一位代表某个数是否出现过

    在3kB范围内呢  
        词频统计法
        生成一个整形数组 3KB/4 最接近2的多少次方 得到 512
        42亿/512 得到a
        生成一个512大小的整形数组 每一位表示在 [a*i,a*(i+1)-1]这个范围上出现的次数
        遍历40亿个数 512大小的数组上每一个数组的值最大就是a，如果某一位上小于a，就表示这个范围上有没有出现过的数
        对这个范围再细分，重复这个过程，一直到数组某一位为0，就表示某个数出现的次数为0

    如果只给你3个变量呢
        二分法  首先取中间值 42亿/2  得到a
        遍历40亿个数，统计小于a的数 count1 和大于a的数count2
        取coutn1和count2中小于a的数来决定接下来在左边还是右边继续二分
        最多遍历log2(42亿个数) 也就是32次 这个40亿个数的大文件




平衡树的删除
    如果删除节点没有左右孩子 父节点的孩子值为空就行
    有一个孩子 父节点的孩子直接指向这个孩子
    左右孩子都存在
       有两种方案删除
       1. 选右子树上最左边的节点  该节点和头结点替换  该节点的右子树给该节点的父节点
       2. 选左子树上最右边的节点  该节点和头结点替换  该节点的左子树给该节点的父节点

    这时查平衡性就从该节点的父节点开始查
    L旋 R旋都是针对头结点  头结点往哪边偏 就是什么旋
    旋转的目的就是让不平衡的节点调整到头结点的位置上去

AVL
SB
红黑树
跳表


窗口不回退模型
打表法
    输入 输出比较简单时  用笨办法获取大量输入和输出结果   总结规律 写成数学结论  改代码
预处理模型
    空间换时间  频繁存在的查询操作用额外空间存储  
概率类题目
已知一个概率函数，生成另一个概率函数
    通用方法 把这个概率函数加工成一个0 1发生器，等概率返回0~1上的函数 f
    然后再看另一个要求返回值的范围可以用几个二进制表示


    比如 有一个函数可以等概率返回13~21上的整数，生成一个可以等概率返回30~59上的函数
    首先 13~16 返回0  17~20 返回1  21就重新调这个函数
    然后 30~59  可以看做  0~29等概率函数的返回值+30
    0~29 需要5个二进制位 可以表示0~31返回的数
    所以调5次 01发生器 计算得到的整数，如果大于29就直接重新调函数
    否则就返回值+30

进阶  一个函数以p概率返回0  1-p概率返回1   设计一个等概率返回0 1的函数
    这个函数调用两次 如果是00 或者 11 就重新调两次
    10 和 01 概率都是 p*(1-p)等概率  10当做1  01当做0返回  



    题目：判断由( 和 ) 组成的字符串是合格的括号字符串
    遍历这个字符串 定义一个变量count 遇到(就++  遇到)就--
    要求 遍历过程中 count不能小于0   即多出来) 左边没有与它配对的
    遍历结束后 count要等于0 
     进阶：这个字符串如果不合格 最少添加多少个(或者)变成合格的字符串
     准备两个变量 count 和 ans 遍历字符串
        遇到左括号 count++
        遇到右括号时 如果count ==0 就 ans++ 代表此时需要补一个左括号   否则 就count-- 
        返回 count +ans   遍历完之后 count值表示多出来的左括号即字符串末尾需要添加count个右括号 ans表示遍历过程中需要补的左括号个数

    进阶
    "()()()"的深度是1,"((()))深度是3  
        求一个括号字符串的深度 
        就是遍历过程中count的最大值
    进阶2  求括号字符串中的最大合格字符串长度
        解法 定义数组dp[i] 表示下标为i结尾的字符串中最大有效长度为dp[i]
        从左往右遍历数组
            如果左括号 {  dp[i]=0
            遇到右括号 看i-1位置
                        如果i-1位置的值是0 表示
                        如果i-1位置的值不是0而是a 那就看下标为 i-a-1位置的值dp[i-a-1] 以及字符串中 i-a-1位置是不是左括号 是的话 那dp[i]=2+dp[i-1]+dp[i-a-1]
                        char[]str =string.toCharArrar();
                        int[]dp = new int[length];
                        for(int i= 1 ;i<length; i++){
                            if (str[i] == ')'){
                                int pre = i-1-dp[i-1] //从i-1位置往前看dp[i-1]个位置 就是看i-1位置结尾的最长有效字符串的头位置
                                if(pre>=0 && str[pre]==')'){//pre位置不越界
                                //   ***********   (        *****         )
                                                   Pre位置       i-1位置   i位置
                                    dp[i] =dp[i-1]+2+(pre >0? dp[pre-1]:0)   //2就是 pre位置和i位置配对上了  dp[pre-1]就是pre前面一段接上
                                }
                            }
                            res = Math.max(res,dp[i]);
                        }
                        return res;}



    假设s和m初始化 s="a"  m=s;
    定义两种操作
    1 m=s   s= s+s ;
    2  s= s+m 
    求最小操作步骤书将s拼接到长度n
        当n是质数的时候  只能调n-1次操作2完成，因为操作1调用次数超过2次之后s不会变成质数*N
            假设调用k次1  m=k*s  s =2k*s 这时候k>2 s长度就不可能是质数
            如果再调用n次操作2   s=(n+2)*k*s  不可能是质数
            所以当要求长度数是质数的时候 就需要调n-1次操作2

        当n不是质数的时候，假设n=a*b*c*d n写成多个质数相乘
        假设进行x次操作之后变成a*b*c*个a，此时就需要变出d个a*b*c来，由于d是质数，所以只能通过d-1次操作2完成
        同理 要得到a*b*c，就需要调用c-1次操作2，所以问题变成 n 可以由哪些质数因子相乘得到  然后减去这些质数因子的个数


        求一个非质数的质数因子之和和个数
        public static int[] divsSumAndCount(int n ){
            int sum =0 ;
            int count =0 ;
            for (int i =2  i<=n ;i++){
                while(n %i == 0){
                    sum+=i;
                    count++ ;
                    n=n/i ;
                }
            }
            return new int[]{sum,count};
        }

    // 判断一个数是不是质数
    public static boolean isPrime(int n){
        if (n<=3){
            return n>1 ;
        }
        for(int i=2 ;i<n ;i++){
            if (n%i == 0){
                return false ;
            }
        }
        return true ;
    }




    topK问题 求最大的前K个
      可以用大根堆  依次弹出k次
      也可以用小根堆，要限制小根堆的大小不能超过K
        先遍历 加入k个元素到小根堆，如果堆满了之后还有元素要加入小根堆：
        当有元素要加入小根堆的时候 如果要加入的元素小于小根堆的堆顶  跳过
        如果要加入的元素大于小根堆的堆顶，小根堆的堆顶弹出，然后这个元素进入堆中
        小根堆维持着目前位置 前K个最大的值
    
        小根堆的方案只要求k个元素的空间  而大根堆需要装下所有元素

根据先序加中序求后序 或者中序加后续求先序
利用先序遍历中任何树树的第一个都是后续遍历中树的最后一个节点这个关系 递归填值
然后根据中序数组来确定左子树和右子树的规模(先序遍历的第一个节点为头节点 在中序遍历中的位置)
将递归行为划分为左子树 右子树分别递归
其中根据头结点去查询中序数组中位置的过程可以利用辅助空间去加速(Map)
pre,in,pos三种顺序的数组分别从i~j，i~j，i~j填值
public  static void preAndInToPosArray(int[] pre  , int[] in , int[]pos , int prei, int prej , int ini, int inj, int posi, int  posj){
	    if (prei>prej){
	        return ;
        }
	    // 切分到只剩一个元素
        //先序遍历中的第一个节点是后续遍历中的最后一个节点
//	    if (prei ==prej){
//	        pos[posj] = pre[prei];
//	        return ;
//        }
        pos[posj]=pre[prei];
	    int find = ini ;
	    for(;find<=inj;find++){
	        if (in[find]==pre[prei]){
	            break;
            }
        }

//        int[] pre = { 1, 2, 4, 5, 3, 6, 7 };
//        int[] in = { 4, 2, 5, 1, 6, 3, 7 };
//        0 0 0 0 0 0 1
//        0 0 2 0 0 0 1
//        4 0 2 0 0 0 1
//        4 5 2 0 0 0 1
//        4 5 2 0 0 3 1
//        4 5 2 6 0 3 1
//        4 5 2 6 7 3 1
//        4 5 2 6 7 3 1

        // 原理 每次从先序遍历中取第一个元素 然后找到这个元素的中序遍历的位置根据这个位置将先序遍历数组分成左右两部分，分别代表左子树和右子树
        // 每次都是取子树的头节点 也就是先序遍历数组的第一个节点 填到对应的后续遍历子数组的最后一个节点
        // 即先序遍历中子树的第一个节点(当前子树的头结点)都是后续遍历中的最后一个节点(当前子树的头结点)
        preAndInToPosArray(pre,in,pos,prei+1,prei+find-ini,ini,find-1,posi,posi+find-ini-1);
	    // 每次都是填的每个子数组的最后一个元素 所以posj-1 因为这个位置的值每次都要被填写
        preAndInToPosArray(pre,in,pos,prei+find-ini+1,prej,find+1,inj,posi+find-ini,posj-1);

    }

    // 根据中序和后序遍历得到先序遍历结果 同理
    public static void inAndPosArrayToPreArray(int[] pre ,int[] in,int[]pos,int prei ,int prej ,int ini ,int inj ,int posi ,int posj){
        if (prei>prej){
            return ;
        }
        pre[prei]=pos[posj];
        int find = ini ;
        for(;find<=inj;find++){
            if (in[find]==pre[prei]){
                break;
            }
        }

        inAndPosArrayToPreArray(pre,in,pos,prei+1,prei+find-ini,ini,find-1,posi,posi+find-ini-1);
        inAndPosArrayToPreArray(pre,in,pos,prei+find-ini+1,prej,find+1,inj,posi+find-ini,posj-1);

	}

求完全二叉树的节点个数
1. 过整个二叉树一遍 O（N）级别
2. O((lgN)^2)的算法 
    首先来到头结点,求整棵树的最大深度h
    然后来到头节点的右节点，求右子树的最大深度h2 如果h2=h-1 说明头结点的左子树是满二叉树，左子树2^h-1个节点
    加上头结点1 加上右子树x个节点 一个 2^h+? 递归去求？
    然后求右子树的深度和右子树的右子树的最大深度 如果相差为1 说明右子树的左子树的满的 这时要去求右子树的右子树有多少节点 递归可能性1
    如果相差大于1 说明右子树的右子树是满的 只是深度很小而已，这时需要去求右子树的左子树有多少节点 递归可能性2
    一直到某一个子树的深度为0 说明来到了叶节点 return 1


最长递增子序列
    动态规划：
        生成一个和原始长度一样的数组dp[i],定义dp[i]为以下标为i结尾的最长递增子序列长度
        index = 0时 dp[0]=1
        index =1时， 
            if arr[1] >arr[2]  dp[1]=1+1 
            else dp[1]=1
        index =N时，遍历0~n-1 取0~n-1中数组值大于arr[N]的并且dp数组中的最大值  dp【n】 =最大值加1
        int max = 0;
        for(int i=0 ;i <n-1;i++){
            if (arr[i]>arr[n]){
                max =Math.max(dp[i],max);
            }
            
        }
        dp[i]=max+1;
        遍历数组中每次去找0~i中比大于arr[i]的最大dp值， n*n 复杂度

        改进方法 不再每次都去找数组左边比当前元素大的元素
        准备一个ends数组 ends[i]有效时s ends[i]表示所有长度为i+1的递增子序列中最小结尾
        一开始ends整个数组全部无效 当arr数组来到0位置上 dp0=1
        此时 ends0=arr0 表示长度为0+1的自增子序列中最小结尾是arr0，因为此时只遍历到arr的第一个元素
        所以正确
        然后arr来到1的位置，此时dp先不动，
        ends中目前有效区就是[0,0],在有效区中二分查找大于等于arr1的最左的位置，
        如果没找到就扩充有效区ends1=arr1，此时在ends中arr1左侧连同自己一共两个数 dp1=2  
        如果找到了，就更新endsi的位置的值endsi=arr1;此时arr1左侧连同自己有几个数，dp1就是多少
        依次遍历arr，对每个元素都这样，先二分查找ends的有效区
        如果没找到大于等于arri的最左的位置，那就扩充有效区
        找到了 就更新有效区
        有效区中元素连同左侧所有元素的个数和就是以这个元素结尾的最长子序列长度
        遍历中二分 n*lgN的复杂度
        经典解法中(也就是动态规划n^2)动态规划过程中存在枚举行为(每次都去0~n-1中数组值大于arr[N]的并且dp数组中的最大值)
        而改进方法在动态规划中构建了一个满足单调性的辅助空间来帮助加速  枚举行为可以用单调性的优化(一种优化思想)
        


        给定一个整数数组A，长度为n，有 1 <= A[i] <= n，且对于[1,n]的整数，其 中部分整数会重复出现而部分不会出现。 实现算法找到[1,n]中所有未出现在A中的整数
        要求：试实现O(n)的时间复杂度和O(1)的空间复杂度
        方法：
            尽量让下标为i的位置上放的值为i+1,对数组中每个元素做这个操作
            然后遍历一遍元素,下标为i的元素的值不为i+1的就输出

看到子串或者子数组问题 就想为i结尾的情况怎么怎么样来递归