选择排序:每次过一遍数组 找到最大值 放到i的位置 i++
冒泡排序：每次过一遍数组 交换相邻的两个数 一直到每一轮的最大值放到后面去
异或运算
题目：  
    1.一个数组中只有一个数出现次数为奇数次 其他全为偶数次   求这个奇数次的数  
        （从头到尾异或）
    2. 1的升级版 一个数组中有两个数出现次数为奇数次 其他全为偶数次   求这两个个奇数次的数  
         从头到尾异或得到eor1 =a^b 提取出eor1中最右侧的1得到 int temp 再过一遍数组 如果 数组中某个数&temp ==0，就让这个数和eor2异或
         过完数组 eor2就是a或者b其中的一个  eor2^eor1得到剩余的一个 
         技巧  提取出一个数中最右侧的1  a&(~a+1)  得到 二进制只有一个1的数

插入排序：前I个元素有序  第i+1个元素过一遍i个数组  i+1位置的元素比i大 就交换


复杂度 0()  一律按照最差情况估计
    比如插入排序按从大到小的顺序排序  如果数据本来就是从大到小有序  O(N)
    如果数据从小到大排序的 O(N^2)

二分查找
    leetcode 162 852 1095

递归算法的时间复杂度 
    T [n] = aT[n/b] + f (n)（直接记为T [n] = aT[n/b] + T (N^d)）
        其中 a >= 1 and b > 1 是常量，其表示的意义是n表示问题的规模，a表示递归的次数也就是生成的子问题数，b表示每次递归是原来的1/b之一个规模，f（n）表示分解和合并所要花费的时间之和。
        解法：
        ①当d<logb a时，时间复杂度为O(n^(logb a))
        ②当d=logb a时，时间复杂度为O((n^d)*logn)
        ③当d>logb a时，时间复杂度为O(n^d)


归并排序  时间复杂度 (nlogn) 空间(nlogn)  可优化空间复杂度为0(1)

小和问题  数组中  一个元素右边比他小的元素累加和 叫做这个元素的小和   对每一个元素求小和累加起来的结果 就是小和结果
    思路转变  相当于求一个数 右侧比他大的数之和   对每一个数这样求，结果累加
    可以在归并排序merge过程中去统计每一个数右侧有多少数比他大并求和

逆序对问题  
    一个数组中 左侧的数大于右侧的数，则这两个数构成逆序对  打印所有的逆序对
    求所有逆序对的和   leetcode     剑指offer51

给定一个值 使得数组中小于该值的数放左边 大于该值的数放右边
荷兰国旗问题  leetcode 75


快排 
    1.0  
    取数组最后一个元素做target  对前n-1个数 让小于等于的放左边 大于的放右边，然后交换最后一个值和大于区域的第一个元素
    然后根据target的坐标，左右两侧划分为两个区域 递归此过程  每次递归能保证有一个数被排好位置
    2.0版本
    也是取数组最后一个元素做target，利用荷兰国旗问题，将前n-1个数划分为小于 等于 大于 三个区域，然后交换最后一个元素
    和大于区域的第一个元素，然后划分小于区域和大于区域 递归下去 这样每次能排序好多个相同的数 效率高于1.0

    1.0和2.0 时间复杂度度都是0(N^2) 最差情况如 [1,2,3,4,5,6,7,8,9]  每次会让一侧区域为空

    3.0版本  随机选一个数组中的数当做target，target和数组最后一个元素交换  执行2.0版本  
        时间复杂度 0(n*logn)  空间复杂度0(logN)



堆
    一颗满二叉树  最大值或者最小值在顶点,对每颗子树也满足这个条件  
    二叉树用数组表示  i位置 左孩子是 2*i+1  右孩子是 2*i+2  父节点  (i-1)/2向下取整

    insert过程  新插入进来的节点和它的父节点比较 如大于父节点就交换 重复这个过程直到到达堆顶或者不大于父节点了
                heapSize --,将数组最后一个元素和根元素交换 ，选取根节点的两个孩子中最大的一个，如果这个最大值
    返回并移除最大值            大于根节点，就交换，然后比较交换过后的子节点和他的左右孩子 重复这个过程  

    堆插入 O(logN) 返回并移除最大值  0(logN)


堆排序 
    给定一个数组  一个一个往大根堆插入  构成大根堆之后  对这个数组 把数组头元素和headSize处的元素交换 
    这样每次最大值就到了数组的最后，然后heapSize -- 这个 堆就变小了一个从小到大的排序
    0(nlogn) O(1)

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元 素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的 排序算法针对这个数据进行排序
    解题思路 ： 选一个容量为k+1的小根堆  遍历数组 依次添加进入heap，满了只有就弹出最小值，从数组下标为0开始，依次填入数组  遍历到最后k个元素的时候，没有元素添加，直接弹出最小值写入数组


非比较的排序算法
    桶排序
        1. 计数排序   
            给定一个数组 先求出最大值和最小值 开辟一个max-min+1 大小的桶(或者数组、队列) 
            遍历数组 对于值为x的数组 放在索引值为x-min+1的位置上,
            遍历之后可得到从小到大每个元素出现的次数  遍历这个桶 依次输出
            /**
            优化 ： 如果出现多个相同的数 要确定哪个是哪个 做法就是 遍历这个桶 当前桶的值=前面所有桶的值之和+当前桶     (此时桶的值的含义是 当前数组中下标对应的元素x应该排在哪个位置上)
            然后从后往前遍历数组 数组值为x的元素在桶的x-min+1上,然后将这个元素输出，再讲桶对应的值-1
            **/
        2. 基数排序
            将数据按照个位、十位、百位、千位等分别放在0-9的桶中，然后遍历桶取出  （一个桶中的元素先进先出）
            按个位排了之后 遍历每个桶中的数据 按十位再排依次 
            按照每一位这样进桶出桶之后就会有序



 链表
    打印两个有序链表的公共部分
    单链表翻转
    双向链表翻转
    链表在a到b个元素上翻转
    链表是否回文          
    链表是否有环
    链表是否相交
    将单向链表按某值划分成左边小、中间相等、右边大的形式 
    rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节 点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。

树
    前序遍历 
    中序遍历
    后序遍历
    层次遍历
    四种遍历方式的非递归实现
    给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点
    后继节点：中序遍历中一个节点的后面节点
    二叉树的序列化和反序列化 就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树 如何判断一颗二叉树是不是另一棵二叉树的子树？
    如何判断一颗二叉树是否是搜索二叉树？ 如何判断一颗二叉树是完全二叉树？ 如何判断一颗二叉树是否是满二叉树？ 如何判断一颗二叉树是否是平衡二叉树？（二叉树题目套路）
图  
    宽度优先遍历
    广度优先遍历
    拓扑排序
    k算法 
    p算法
    d算法


前缀树

贪心

布隆过滤器  (给定样本量和失误率，可以计算出需要的内存大小 hash函数的个数  以及实际的失误率) 
一致性hash (虚拟节点抢占)

岛屿问题
    岛屿问题用并行算法
并查集
kmp
manacher算法（O（n）查找一个字符串的最长回文子串）

滑动窗口  （窗口内最大值或者最小值更新结构）
    一个窗口LR 可以选择L或者R往右移动，但L不能超过R 维护这个窗口的最大值
    流程  准备一个双端队列  目标:随时获取窗口内最大值 双端队列存放数组下标
        滑动过程中保证队列内元素有序  L为头部 R为尾部
        如果让R动  判断此时要进入的元素是否大于队列中头部元素
           如果元素小于队列头部元素 则元素从尾部进入队列  
           否则队列内的元素从尾部开始一条一条弹出，知道队列为空或者队列头部节点大于待进入的元素
            即窗口内从左到右依次减小，当进入一个元素时，从右往左依次弹出，一直到这个元素
            可以放进一个大于它的元素的后面
            3 2 4 6 3 7 5 3 5  R往右动  维持最大值在头部 就是L处
            [3]  [3,2]  [4](2,3依次弹出) [6] [6,3] [7][7 5 ][7,5,3] [7,5](3,5依次弹出 然后新的5进入  严格保证弹出元素小于当前进入元素)
            L往右动的时候 
                如果过期的元素是头部元素 就弹出
                如果过期元素不是头部元素 不用管
                L R 实际上是两个代表位置的遍历   双端队列里面是从大到小的元素

                6 4 2 5 3 
                如果R到达下标为2的位置  双端队列 [0,1,2] (头--- 尾) 放的下标
                此时 L=0， R=2 此时L右移 L=1 查看下标为0的元素是不是队列的头部元素
                  是的  所以6移除
                  L再右移 4移除  
                  此时R右移  到下标为4的位置  队列中[3,4]（也就是5,3）
                  此时L右移 发现下标为2的位置不是队列中的头部元素 什么都不做


单调栈（一个数组中每一个元素左边比他大且距离最近的元素和右边比他大且距离最近的元素）0(n)
 5 4 3 6 1 2 0 7
   流程： 如果求左右两边比当前元素大的  就准备一个单调栈(从栈底到栈顶从大到小)
   流程： 如果求左右两边比当前元素小的  就准备一个单调栈(从栈底到栈顶从小到大)
        依次遍历  下标放入栈底
        假设栈底~栈顶 从左到右 []
        [0,1,2] 此时来到6 发现不能放入栈顶 弹出栈顶
          弹出时弹出a2  此时 a2右边比他大的数就是6 右边比他大的数就是他在栈中的下一个元素 a1  记录(a1,a3)
          然后弹出a1  同理 记录  (a1,a3)
          然后弹出a0 (null,a3)
          然后a3压入栈底
       




树形DP


Morris遍历
    利用叶节点的空闲指针代替栈完成遍历
    遍历规则
    假设当前来到cur节点
    1. 如果cur没有左孩子 cur向右移动 cur =cur.right
    2. 如果cur有左孩子 找到左子树上最右的节点 mostRight
        2.1  如果mostRight的右指针指向空，让其指向cur
             然后cur向左移  cur =cur.left   重复这个过程
        2.2 如果mostRight的右指针指向cur，让其指向null
            然后cur向右移   cur =cur.right  重复这个过程
    3. cur为空时遍历停止
    有左树的节点能到两次，没有左树的节点只能到一次

    morris遍历改先序遍历
        如果一个节点只能到达一次 直接打印   能到达两次  第一次打印
    morris遍历改中序遍历
        如果节点只能到达一次  直接打印  能到达两次 第二次打印
    morris遍历改后序遍历
        对于第二次遍历的节点，逆序打印左树的右边界
        遍历完之后单独逆序打印整棵树的右边界
    
    判断一棵树是不是搜索二叉树
    如果中序遍历是升序就是搜索二叉树
    bitmap   40亿个数在整数范围上(大概是42亿)  在 1G范围内 判断哪个数没有出现过
    42亿/8差不多 512M 大小  生成一个bit类型的数组  512M  每一位代表某个数是否出现过

    在3kB范围内呢  
        词频统计法
        生成一个整形数组 3KB/4 最接近2的多少次方 得到 512
        42亿/512 得到a
        生成一个512大小的整形数组 每一位表示在 [a*i,a*(i+1)-1]这个范围上出现的次数
        遍历40亿个数 512大小的数组上每一个数组的值最大就是a，如果某一位上小于a，就表示这个范围上有没有出现过的数
        对这个范围再细分，重复这个过程，一直到数组某一位为0，就表示某个数出现的次数为0

    如果只给你3个变量呢
        二分法  首先取中间值 42亿/2  得到a
        遍历40亿个数，统计小于a的数 count1 和大于a的数count2
        取coutn1和count2中小于a的数来决定接下来在左边还是右边继续二分
        最多遍历log2(42亿个数) 也就是32次 这个40亿个数的大文件




平衡树的删除
    如果删除节点没有左右孩子 父节点的孩子值为空就行
    有一个孩子 父节点的孩子直接指向这个孩子
    左右孩子都存在
       有两种方案删除
       1. 选右子树上最左边的节点  该节点和头结点替换  该节点的右子树给该节点的父节点
       2. 选左子树上最右边的节点  该节点和头结点替换  该节点的左子树给该节点的父节点

    这时查平衡性就从该节点的父节点开始查
    L旋 R旋都是针对头结点  头结点往哪边偏 就是什么旋
    旋转的目的就是让不平衡的节点调整到头结点的位置上去

AVL
SB
红黑树
跳表


窗口不回退模型
打表法
    输入 输出比较简单时  用笨办法获取大量输入和输出结果   总结规律 写成数学结论  改代码
预处理模型
    空间换时间  频繁存在的查询操作用额外空间存储  
概率类题目
已知一个概率函数，生成另一个概率函数
    通用方法 把这个概率函数加工成一个0 1发生器，等概率返回0~1上的函数 f
    然后再看另一个要求返回值的范围可以用几个二进制表示


    比如 有一个函数可以等概率返回13~21上的整数，生成一个可以等概率返回30~59上的函数
    首先 13~16 返回0  17~20 返回1  21就重新调这个函数
    然后 30~59  可以看做  0~29等概率函数的返回值+30
    0~29 需要5个二进制位 可以表示0~31返回的数
    所以调5次 01发生器 计算得到的整数，如果大于29就直接重新调函数
    否则就返回值+30

进阶  一个函数以p概率返回0  1-p概率返回1   设计一个等概率返回0 1的函数
    这个函数调用两次 如果是00 或者 11 就重新调两次
    10 和 01 概率都是 p*(1-p)等概率  10当做1  01当做0返回  



    题目：判断由( 和 ) 组成的字符串是合格的括号字符串
    遍历这个字符串 定义一个变量count 遇到(就++  遇到)就--
    要求 遍历过程中 count不能小于0   即多出来) 左边没有与它配对的
    遍历结束后 count要等于0 
     进阶：这个字符串如果不合格 最少添加多少个(或者)变成合格的字符串
     准备两个变量 count 和 ans 遍历字符串
        遇到左括号 count++
        遇到右括号时 如果count ==0 就 ans++ 代表此时需要补一个左括号   否则 就count-- 
        返回 count +ans   遍历完之后 count值表示多出来的左括号即字符串末尾需要添加count个右括号 ans表示遍历过程中需要补的左括号个数

    进阶
    "()()()"的深度是1,"((()))深度是3  
        求一个括号字符串的深度 
        就是遍历过程中count的最大值
    进阶2  求括号字符串中的最大合格字符串长度
        解法 定义数组dp[i] 表示下标为i结尾的字符串中最大有效长度为dp[i]
        从左往右遍历数组
            如果左括号 {  dp[i]=0
            遇到右括号 看i-1位置
                        如果i-1位置的值是0 表示
                        如果i-1位置的值不是0而是a 那就看下标为 i-a-1位置的值dp[i-a-1] 以及字符串中 i-a-1位置是不是左括号 是的话 那dp[i]=2+dp[i-1]+dp[i-a-1]
                        char[]str =string.toCharArrar();
                        int[]dp = new int[length];
                        for(int i= 1 ;i<length; i++){
                            if (str[i] == ')'){
                                int pre = i-1-dp[i-1] //从i-1位置往前看dp[i-1]个位置 就是看i-1位置结尾的最长有效字符串的头位置
                                if(pre>=0 && str[pre]==')'){//pre位置不越界
                                //   ***********   (        *****         )
                                                   Pre位置       i-1位置   i位置
                                    dp[i] =dp[i-1]+2+(pre >0? dp[pre-1]:0)   //2就是 pre位置和i位置配对上了  dp[pre-1]就是pre前面一段接上
                                }
                            }
                            res = Math.max(res,dp[i]);
                        }
                        return res;}



    假设s和m初始化 s="a"  m=s;
    定义两种操作
    1 m=s   s= s+s ;
    2  s= s+m 
    求最小操作步骤书将s拼接到长度n
        当n是质数的时候  只能调n-1次操作2完成，因为操作1调用次数超过2次之后s不会变成质数*N
            假设调用k次1  m=k*s  s =2k*s 这时候k>2 s长度就不可能是质数
            如果再调用n次操作2   s=(n+2)*k*s  不可能是质数
            所以当要求长度数是质数的时候 就需要调n-1次操作2

        当n不是质数的时候，假设n=a*b*c*d n写成多个质数相乘
        假设进行x次操作之后变成a*b*c*个a，此时就需要变出d个a*b*c来，由于d是质数，所以只能通过d-1次操作2完成
        同理 要得到a*b*c，就需要调用c-1次操作2，所以问题变成 n 可以由哪些质数因子相乘得到  然后减去这些质数因子的个数


        求一个非质数的质数因子之和和个数
        public static int[] divsSumAndCount(int n ){
            int sum =0 ;
            int count =0 ;
            for (int i =2  i<=n ;i++){
                while(n %i == 0){
                    sum+=i;
                    count++ ;
                    n=n/i ;
                }
            }
            return new int[]{sum,count};
        }

    // 判断一个数是不是质数
    public static boolean isPrime(int n){
        if (n<=3){
            return n>1 ;
        }
        for(int i=2 ;i<n ;i++){
            if (n%i == 0){
                return false ;
            }
        }
        return true ;
    }




    topK问题 求最大的前K个
      可以用大根堆  依次弹出k次
      也可以用小根堆，要限制小根堆的大小不能超过K
        先遍历 加入k个元素到小根堆，如果堆满了之后还有元素要加入小根堆：
        当有元素要加入小根堆的时候 如果要加入的元素小于小根堆的堆顶  跳过
        如果要加入的元素大于小根堆的堆顶，小根堆的堆顶弹出，然后这个元素进入堆中
        小根堆维持着目前位置 前K个最大的值
    
        小根堆的方案只要求k个元素的空间  而大根堆需要装下所有元素

根据先序加中序求后序 或者中序加后续求先序
利用先序遍历中任何树树的第一个都是后续遍历中树的最后一个节点这个关系 递归填值
然后根据中序数组来确定左子树和右子树的规模(先序遍历的第一个节点为头节点 在中序遍历中的位置)
将递归行为划分为左子树 右子树分别递归
其中根据头结点去查询中序数组中位置的过程可以利用辅助空间去加速(Map)
pre,in,pos三种顺序的数组分别从i~j，i~j，i~j填值
public  static void preAndInToPosArray(int[] pre  , int[] in , int[]pos , int prei, int prej , int ini, int inj, int posi, int  posj){
	    if (prei>prej){
	        return ;
        }
	    // 切分到只剩一个元素
        //先序遍历中的第一个节点是后续遍历中的最后一个节点
//	    if (prei ==prej){
//	        pos[posj] = pre[prei];
//	        return ;
//        }
        pos[posj]=pre[prei];
	    int find = ini ;
	    for(;find<=inj;find++){
	        if (in[find]==pre[prei]){
	            break;
            }
        }

//        int[] pre = { 1, 2, 4, 5, 3, 6, 7 };
//        int[] in = { 4, 2, 5, 1, 6, 3, 7 };
//        0 0 0 0 0 0 1
//        0 0 2 0 0 0 1
//        4 0 2 0 0 0 1
//        4 5 2 0 0 0 1
//        4 5 2 0 0 3 1
//        4 5 2 6 0 3 1
//        4 5 2 6 7 3 1
//        4 5 2 6 7 3 1

        // 原理 每次从先序遍历中取第一个元素 然后找到这个元素的中序遍历的位置根据这个位置将先序遍历数组分成左右两部分，分别代表左子树和右子树
        // 每次都是取子树的头节点 也就是先序遍历数组的第一个节点 填到对应的后续遍历子数组的最后一个节点
        // 即先序遍历中子树的第一个节点(当前子树的头结点)都是后续遍历中的最后一个节点(当前子树的头结点)
        preAndInToPosArray(pre,in,pos,prei+1,prei+find-ini,ini,find-1,posi,posi+find-ini-1);
	    // 每次都是填的每个子数组的最后一个元素 所以posj-1 因为这个位置的值每次都要被填写
        preAndInToPosArray(pre,in,pos,prei+find-ini+1,prej,find+1,inj,posi+find-ini,posj-1);

    }

    // 根据中序和后序遍历得到先序遍历结果 同理
    public static void inAndPosArrayToPreArray(int[] pre ,int[] in,int[]pos,int prei ,int prej ,int ini ,int inj ,int posi ,int posj){
        if (prei>prej){
            return ;
        }
        pre[prei]=pos[posj];
        int find = ini ;
        for(;find<=inj;find++){
            if (in[find]==pre[prei]){
                break;
            }
        }

        inAndPosArrayToPreArray(pre,in,pos,prei+1,prei+find-ini,ini,find-1,posi,posi+find-ini-1);
        inAndPosArrayToPreArray(pre,in,pos,prei+find-ini+1,prej,find+1,inj,posi+find-ini,posj-1);

	}

求完全二叉树的节点个数
1. 过整个二叉树一遍 O（N）级别
2. O((lgN)^2)的算法 
    首先来到头结点,求整棵树的最大深度h
    然后来到头节点的右节点，求右子树的最大深度h2 如果h2=h-1 说明头结点的左子树是满二叉树，左子树2^h-1个节点
    加上头结点1 加上右子树x个节点 一个 2^h+? 递归去求？
    然后求右子树的深度和右子树的右子树的最大深度 如果相差为1 说明右子树的左子树的满的 这时要去求右子树的右子树有多少节点 递归可能性1
    如果相差大于1 说明右子树的右子树是满的 只是深度很小而已，这时需要去求右子树的左子树有多少节点 递归可能性2
    一直到某一个子树的深度为0 说明来到了叶节点 return 1


最长递增子序列
    动态规划：
        生成一个和原始长度一样的数组dp[i],定义dp[i]为以下标为i结尾的最长递增子序列长度
        index = 0时 dp[0]=1
        index =1时， 
            if arr[1] >arr[2]  dp[1]=1+1 
            else dp[1]=1
        index =N时，遍历0~n-1 取0~n-1中数组值大于arr[N]的并且dp数组中的最大值  dp【n】 =最大值加1
        int max = 0;
        for(int i=0 ;i <n-1;i++){
            if (arr[i]>arr[n]){
                max =Math.max(dp[i],max);
            }
            
        }
        dp[i]=max+1;
        遍历数组中每次去找0~i中比大于arr[i]的最大dp值， n*n 复杂度

        改进方法 不再每次都去找数组左边比当前元素大的元素
        准备一个ends数组 ends[i]有效时s ends[i]表示所有长度为i+1的递增子序列中最小结尾
        一开始ends整个数组全部无效 当arr数组来到0位置上 dp0=1
        此时 ends0=arr0 表示长度为0+1的自增子序列中最小结尾是arr0，因为此时只遍历到arr的第一个元素
        所以正确
        然后arr来到1的位置，此时dp先不动，
        ends中目前有效区就是[0,0],在有效区中二分查找大于等于arr1的最左的位置，
        如果没找到就扩充有效区ends1=arr1，此时在ends中arr1左侧连同自己一共两个数 dp1=2  
        如果找到了，就更新endsi的位置的值endsi=arr1;此时arr1左侧连同自己有几个数，dp1就是多少
        依次遍历arr，对每个元素都这样，先二分查找ends的有效区
        如果没找到大于等于arri的最左的位置，那就扩充有效区
        找到了 就更新有效区
        有效区中元素连同左侧所有元素的个数和就是以这个元素结尾的最长子序列长度
        遍历中二分 n*lgN的复杂度
        经典解法中(也就是动态规划n^2)动态规划过程中存在枚举行为(每次都去0~n-1中数组值大于arr[N]的并且dp数组中的最大值)
        而改进方法在动态规划中构建了一个满足单调性的辅助空间来帮助加速  枚举行为可以用单调性的优化(一种优化思想)
        


        给定一个整数数组A，长度为n，有 1 <= A[i] <= n，且对于[1,n]的整数，其 中部分整数会重复出现而部分不会出现。 实现算法找到[1,n]中所有未出现在A中的整数
        要求：试实现O(n)的时间复杂度和O(1)的空间复杂度
        方法：
            尽量让下标为i的位置上放的值为i+1,对数组中每个元素做这个操作
            然后遍历一遍元素,下标为i的元素的值不为i+1的就输出

看到子串或者子数组问题 就想为i结尾的情况怎么怎么样来递归




子数组累加和为k的最长子数组长度问题三连
1. 正数数组中子数组和为的k的最长子数组问题
   用单调性解决 滑动窗口
   首先窗口都在-1处,R<arr.length为终止条件
   首先R++ 求窗口内元素之和 如果大于>K L++
   如果小于K r++ 
   如果等于k 记录R-L的值为长度  然后R++

2  数组无序，有正数有负数还有0的情况
    定义一个Map  k为数组从0开始到i位置的累加和  v就是此时的下标i，注意 这个map只记录最早一次出现
    sum和为某一个数的i
    比如0~2的和为5 0~6的和也为5 map存的还是(5,2) 
    计算sum-k作为key出现在map中的位置
        如果sum-k作为key出现在map中 假设为 k ，v1  那么v1+1 到当前位置i就是累加和为k
        因为 0~v1的累加和为sum-k,而0~i累加和为sum，所以 v1~i的累加和为 sum-(sum-k) 也就是k
        计算此时的i-v1 作为子数组第一次出现的最长长度
        
    如果sum-k没有出现在map中 查看当前sum是否在map中 没有就加上 存在就不管
    因为存在的话 那么它的k也就是下标肯定小于现在的下标，也就是长度要比现在要长，所以不能覆盖

    依次遍历完数组 得到最长子数组的长度
    特别注意累加和为0的起始位置为-1
    public static int maxLength(int[] arr, int k) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>(); // 含义：<从0位置元素的累加和, 满足此累加和的最小下标>
		map.put(0, -1); // 注意不要写成 (0, 0)
		int len = 0;
		int sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
			if (map.containsKey(sum - k)) {
				len = Math.max(i - map.get(sum - k), len);
			}
			if (!map.containsKey(sum)) {
				map.put(sum, i);
			}
		}
		return len;
	}

   3   数组无序，有正数有负数还有0的情况,求数组累加和小于等于k的最长子数组长度问题
     首先求一个maxI数据 表示从i出发的子数组的最小累加和
     然后求一个maxEnd 表示从i出发取到最长子数组长度的时候的右边界

     这两个数组从右往左求  来到maxI的时候，如果
        maxI[i+1]>0
            arr[i]>0 就不扩
            arr[i]<=0 就扩
        maxI[i+1]<0
            arr[i]>0 
    
    求完两个数组之后，从i从0开始，求小于等于k的最长子数组
    先看maxI[0]的值以及maxEnd[0]这样可以看从0开始到哪一段是从0开始最小累加和子数组
    这就要可以得到多个连续的子数组累加和小于等于K
    记下此时的子数组长度i~j,累加和sum
    然后i++，此时sum=sum-arr[0] 看看1开始的子数组还能不能往后扩 (看naxI)  
    能扩就扩 依次i++ 看看最大值
    然后从j+1开始 重复这个过程 j就是从0位置开始拿到的小于等于k的最长子数组的右边界
    依次重复




    给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右 括号，
    返回公式的计算结果。 
    【举例】 str="48*((70-65)-43)+8*1"，
    返回-1816。 str="3+1*4"，返回7。 
    str="3+(1*4)"，返回7。 
    【说明】 1．可以认为给定的字符串一定是正确的公式，
    即不需要对str做公式有效性检查。 
    2．如果是负数，就需要用括号括起来，比如"4*(-3)"。
    但如果负数作为公式的开头 或括号部分的开头，
    则可以没有括号，比如"-3*4"和"(-3*4)"都是合法的。 
    3．不用考虑计算过程中会发生溢出的情况。

        对于没有左右括号的加减乘除的字符串
        首先遍历 遇到运算符就看栈顶元素是不是乘或者除，不是就把遇到的数字和符号压栈
                            如果栈顶元素是乘和除，那就从栈中弹出两个元素,和当前遍历到的数字
                            先运算，然后连同遇到的运算符一起压栈
    

    给定两个字符串str1和str2，求两个字符串的最长公共子串。
        dp[i][j] 表示str1以i位置结尾,str2以j位置结尾的最长公共子序列

        首先 第一行 第一列中 如果两个字符串对应位置不相等就是0 相等就是1
        然后 dp[i][j]  如果str1的i位置和str2的j位置相等 那么dp[i][j] =dp[i-1][j-1]
        否则 dp[i][j]=0
    
    给定两个字符串str1和str2，求两个字符串的最长公共子序列。
        dp[i][j] 表示 str1从0到i位置和str2中从0到j中的最长公共子序列
        那么dp数组右下角的值就是答案
        可能性分析
        1 i，j位置都不是子序列的结尾位置  dp[i][j]=dp[i-1][j-1]
        2 以i结尾但不以j结尾 dp[i][j]=dp[i-1][j]
        3 不以i结尾但以j结尾 dp[i][j]=dp[i][j-1]
        4 同时以i，j结尾  if(str1[i]==str2[j]) dp[i][j]=dp[i-1][j-1]+1
        以上四种可能性 求max

    字符串最长回文子串
        manacher算法    
    动态规划四种尝试模型
        一、从左到右的尝试模型   dp[i]
             i位置要或者不要 
             i位置有或者没有
             即以i作为开头的可能性
        二、范围上的尝试模型  dp[i][j]  
            依赖于 dp[i-1][j-1] dp[i]dp[j-1] dp[i-1]dp[j]
            分成四种
             以i开头j结尾 和不i不j通常是互斥 需要满足某种题目条件才会有这种可能性
             不i不j
             i不就
             不i但j
        三、多样本位置全对应的尝试模型'
            dp[i][j] a以i结尾 b以j结尾
        四、寻找业务限制的尝试模型

        从dp数组可以还原出当时的选择路径，如果某一个路径有多个分支，深度优选遍历可以还原所有的答案
        
    
    求字符串的最长回文子序列
        方法1：
            生成原始串s1的逆序串 s2        
            把问题转化成 s1 s2的最长公共子序列问题
            求出的s1,s2的最长公共子序列长度/2就是原问题中回文串的前半部分
        方法2：
            范围上尝试模型：以开头和结尾划分可能性
            dp[i][j]表示str从i到j位置的最长回文子序列
            右上角就是所需答案
            对角线下半区域无意义 j<1
            从对角线开始填 对角线全是1 ：
                 因为一个字符构成长度为1的回文字符串
            填倒数第二条对角线：
                两个字符相等就是2  不相等就是1   
            划分可能性：
               1. 以i开头 j结尾 dp[i][j] = dp[i-1][j-1]+2 即加上开头和结尾
               2. 以i块头  不以j结尾  dp[i][j] = dp[i][j-1]
               3. 不以i开头 以j结尾    dp[i][j] = dp[i-1][j]
               4 不以i开头 也不以j结尾   dp[i][j] = dp[i-1][j-1]


    给定一个字符串,字符串可以在任意位置添加字符
        求字符串在至少添加几个字符可以构成回文串
        范围上尝试模型
        dp[i][j] str[i,j]至少填多少个字符构成范围上回文
        对角线左侧不用管 对角线都是0
        对角线上一条对角线，两个字符相等就是0 不等就是1
        可能性分析:
            1. 先把i+1，j范围构成回文，再在j后面加一个i位置对应的字符 整体构成回文
                dp[i][j] = dp[i+1][p]+1;
            2  先i，j-1 构成回文 j然后i-1的位置加上一个j位置的字符 
                dp[i][j] = dp[i][j-1]+1
            3 如果 i，j位置相等 搞定i-1,j-1





     topK问题 求最大的前K个
      
        1. 大根堆小根堆 
            可以用大根堆  依次弹出k次,但这种方案需要将所有元素全放在大根堆中，空间消耗较大
            小根堆  先放入前K的元素，看剩下的元素和堆顶比较，如果堆顶小于当前元素，就弹出堆顶，
            然后把这个元素进堆

        2. 利用快排的partion过程，随机选一个数，小于这个数的放左边，
            等于这个数的放中间，大于这个数的放右边。然后看k有没有命中L~R的范围
            命中就直接返回选中的数，否则就递归左侧或者右侧 左右两侧每次只递归一次
            最好情况0(n)最坏情况O(n^2),随机选取一个数的话时间O(n)
        3 BFPRT算法
            类似方法2也是使用快排的partion，只是在选择数的方法上不是随机，其他过程都一样
            选数的方法:
                首选将原数组按下标分组，M个元素分成一组
                然后每一组组内排序取中位数，得到所有组的中位数构成的数组
                然后对这个数组再排序取中位数(上中位数)，这个数就是划分数


                设一个函数select(arr,begin,end,i)//从一个无序数组arr的begin到end范围上求如果从小到大拍完序之后下标为i的位置的元素
                再设一个函数int[] medianOfMedians(arr,being,end)//从arr的being到end位置上求按照5个元素一组，求每组中位数构成的中位数组中的中位数
                其中medianOfMedians中拿到了中位数构成的中位数数组之后，再调用select(arr,0,arr.length,arr.length/2) 去找arr的上中位数
                而select过程也需要去调用medianOfMedians拿到每一次选取的中位数
                所以是两个函数嵌套递归下去

                    public static int select(int[] arr, int begin, int end, int i) {
                        if (begin == end) {
                            return arr[begin];
                        }
                        int pivot = medianOfMedians(arr, begin, end);
                        //partition过程 返回LR的下标
                        int[] pivotRange = partition(arr, begin, end, pivot);
                        if (i >= pivotRange[0] && i <= pivotRange[1]) {
                            return arr[i];
                        } else if (i < pivotRange[0]) {
                            //去左侧排序，求第i小的数
                            return select(arr, begin, pivotRange[0] - 1, i);
                        } else {
                            return select(arr, pivotRange[1] + 1, end, i);
                        }
                    }

                    public static int medianOfMedians(int[] arr, int begin, int end) {
                        int num = end - begin + 1;
                        int offset = num % 5 == 0 ? 0 : 1;
                        //中位数组成的中位数组
                        int[] mArr = new int[num / 5 + offset];
                        for (int i = 0; i < mArr.length; i++) {
                            int beginI = begin + i * 5;
                            int endI = beginI + 4;
                            //每一组上分别排序再求中位数
                            mArr[i] = getMedian(arr, beginI, Math.min(end, endI));
                        }
                        // mArr生成了每组中位数构成的中位数数组
                        // 调用select 在mArr上去找上中位数
                        return select(mArr, 0, mArr.length - 1, mArr.length / 2);
                    }

                    public static int[] partition(int[] arr, int begin, int end, int pivotValue) {
                        int small = begin - 1;
                        int cur = begin;
                        int big = end + 1;
                        while (cur != big) {
                            if (arr[cur] < pivotValue) {
                                swap(arr, ++small, cur++);
                            } else if (arr[cur] > pivotValue) {
                                swap(arr, cur, --big);
                            } else {
                                cur++;
                            }
                        }
                        int[] range = new int[2];
                        range[0] = small + 1;
                        range[1] = big - 1;
                        return range;
                    }

洗牌问题：

    [A,B,C,D,E,甲,乙] 一个数组分为左右两个 怎么把左侧移到右侧  右侧移到左侧 变成[甲,乙,A,B,C,D,E]
    方法: 左侧逆序 右侧逆序 然后整体再逆序 O(N)
        对于左侧:用两个指针分别指向头尾  交换头尾的元素 然后头++ 尾-- 知道 头==尾  也就是左侧部分逆序 edcba
        同理 右侧逆序  乙甲
        然后整体逆序 edcba乙甲  -> 甲乙abcde

    给定一个长度为偶数的数组arr，长度记为2*N。前N个为左部分，后N个为右部分。 arr就可以表示为{L1,L2,..,Ln,R1,R2,..,Rn}， 请将数组调整成{R1,L1,R2,L2,..,Rn,Ln}的样子。
        洗牌问题公式：
            左侧元素i 洗完之后的位置就是2i
            右侧元素j 洗完之后的位置就是2*(j-n)-1;
        
        对于长度为3^n -1长度的偶数数组  每次调整的起始位置为3^(n-1)的位置，拿到这个位置，每次都能循环一圈调整好部分元素，对于每个3^(n-1)都这样，就可以调整好3^n -1长度的数组
            可以从第一个元素开始调整它的位置,假设它应该要去到y位置，拿到原来y位置的元素a，算出y位置的元素要去到哪里，就这样利用洗牌公式
            可以循环调整
        但这只是特殊长度的数组的洗牌方式
        对于任意长度a,首先先求出最接近a的3^k-1的长度b，对于左侧的右半部分X和右侧的b/2长度，作为左部分和右部分，交换左右两部分，这样数组中前b个数就是左侧前b/2 右侧前b/2个数组成的。
        这b个数构成的就是特殊长度的洗牌数组，可以利用上述的从3^(n-1)位置循环调整的方式调整，这样前b个数就洗好了
        剩下的a-b重复上述过程
            example：
            14个数 L1 L2 L3 L4 L5 L6 L7 L8 R1 R2 R3 R4 R5 R6 R7 R8 
                先找到最接近的3^K-1 即k=2时的8,将数组划分为L1L2L3L4  L5L6L7R1R2R3R4 R5R6R7  其中L5L6L7R1R2R3R4就是L5L6L7作部分R1R2R3R4右部分交换左右两侧
                得到 L1L2L3L4  R1R2R3R4L5L6L7  R5R6R7 然后 L1L2L3L4  R1R2R3R4洗牌 得到 R1L1R2L3R3L3R4L4  L5L6L7R5R6R7 
                前8个洗完，后面L5L6L7R5R6R7重复上述过程 找到k=1  L5 L6L7R5 R6R7 交换得到-> L5  R5L6L7 R6R7 前2个洗牌->L5R5 L6L7R6R7 
                对L6L7R6R7重复   k=1  L6 L7R6 R7  交换->L6 R6L7 R7 洗牌->L6R6 L7R7 对L7R7再重复
                总体时间复杂度O(N*log3 N) 空间复杂度O(1)
    洗牌问题相似题 wiggleSort
        给定一个无序数组 长度奇数偶数不定，要求排序成nums[0] <= nums[1] >= nums[2] <= nums[3]=>nums[4]  拍动排序
        思路 ： 首先对数组排序  采用堆排可以额外空间复杂度0(1)
          分类讨论：
          如果数组长度偶数：L1 L2 L3 ... R1 R2 R3   
          利用完美洗牌算法 改成R1L1 R2L2 R3L3 R4L4...
          然后没两个元素交换位置 L1R1 L2R2 L3R3 ...  做到了wiggleSort

          如果数组长度奇数  L0 L1L2L3 ... R1R2R3 
          L0不动 对于 L1L2L3 ... R1R2R3  洗牌 -> R1L1R2L2R3L3....
          整体L0R1L1R2L2R3L3 符合wiggleSort

