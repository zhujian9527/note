选择排序:每次过一遍数组 找到最大值 放到i的位置 i++
冒泡排序：每次过一遍数组 交换相邻的两个数 一直到每一轮的最大值放到后面去
异或运算
题目：  
    1.一个数组中只有一个数出现次数为奇数次 其他全为偶数次   求这个奇数次的数  
        （从头到尾异或）
    2. 1的升级版 一个数组中有两个数出现次数为奇数次 其他全为偶数次   求这两个个奇数次的数  
         从头到尾异或得到eor1 =a^b 提取出eor1中最右侧的1得到 int temp 再过一遍数组 如果 数组中某个数&temp ==0，就让这个数和eor2异或
         过完数组 eor2就是a或者b其中的一个  eor2^eor1得到剩余的一个 
         技巧  提取出一个数中最右侧的1  a&(~a+1)  得到 二进制只有一个1的数

插入排序：前I个元素有序  第i+1个元素过一遍i个数组  i+1位置的元素比i大 就交换


复杂度 0()  一律按照最差情况估计
    比如插入排序按从大到小的顺序排序  如果数据本来就是从大到小有序  O(N)
    如果数据从小到大排序的 O(N^2)

二分查找
    leetcode 162 852 1095

递归算法的时间复杂度 
    T [n] = aT[n/b] + f (n)（直接记为T [n] = aT[n/b] + T (N^d)）
        其中 a >= 1 and b > 1 是常量，其表示的意义是n表示问题的规模，a表示递归的次数也就是生成的子问题数，b表示每次递归是原来的1/b之一个规模，f（n）表示分解和合并所要花费的时间之和。
        解法：
        ①当d<logb a时，时间复杂度为O(n^(logb a))
        ②当d=logb a时，时间复杂度为O((n^d)*logn)
        ③当d>logb a时，时间复杂度为O(n^d)


归并排序

小和问题  数组中  一个元素右边比他小的元素累加和 叫做这个元素的小和   对每一个元素求小和累加起来的结果 就是小和结果
    思路转变  相当于求一个数 右侧比他大的数之和   对每一个数这样求，结果累加
    可以在归并排序merge过程中去统计每一个数右侧有多少数比他大并求和

逆序对问题  
    一个数组中 左侧的数大于右侧的数，则这两个数构成逆序对  打印所有的逆序对
    求所有逆序对的和   leetcode     剑指offer51

给定一个值 使得数组中小于该值的数放左边 大于该值的数放右边
荷兰国旗问题  leetcode 75


快排 
    1.0  
    取数组最后一个元素做target  对前n-1个数 让小于等于的放左边 大于的放右边，然后交换最后一个值和大于区域的第一个元素
    然后根据target的坐标，左右两侧划分为两个区域 递归此过程  每次递归能保证有一个数被排好位置
    2.0版本
    也是取数组最后一个元素做target，利用荷兰国旗问题，将前n-1个数划分为小于 等于 大于 三个区域，然后交换最后一个元素
    和大于区域的第一个元素，然后划分小于区域和大于区域 递归下去 这样每次能排序好多个相同的数 效率高于1.0

    1.0和2.0 时间复杂度度都是0(N^2) 最差情况如 [1,2,3,4,5,6,7,8,9]  每次会让一侧区域为空

    3.0版本  随机选一个数组中的数当做target，target和数组最后一个元素交换  执行2.0版本  
        时间复杂度 0(n*logn)


